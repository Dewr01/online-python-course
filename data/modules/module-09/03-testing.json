{
    "title": "Тестирование",
    "theory": "**Тестирование** — критически важная практика разработки для обеспечения качества кода.\n## Зачем нужно тестирование\n\n**Преимущества тестирования:**\n- Обнаружение ошибок на раннем этапе\n- Уверенность в работоспособности кода\n- Упрощение рефакторинга\n- Документирование ожидаемого поведения\n- Повышение качества кода\n\n**Типы тестов:**\n- **Unit тесты** — тестирование отдельных функций\n- **Integration тесты** — тестирование взаимодействия компонентов\n- **End-to-end тесты** — тестирование полного пользовательского сценария\n\n## Модуль unittest\n\n**unittest** — стандартный модуль Python для написания тестов.\n\n**Базовый синтаксис:**\n```python\nimport unittest\n\nclass TestCalculator(unittest.TestCase):\n    def test_addition(self):\n        result = 2 + 2\n        self.assertEqual(result, 4)\n    \n    def test_subtraction(self):\n        result = 5 - 3\n        self.assertEqual(result, 2)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n## Основные методы assert\n\n**Проверка равенства:**\n```python\nself.assertEqual(actual, expected)  # ==\nself.assertNotEqual(actual, expected)  # !=\n```\n\n**Проверка истинности:**\n```python\nself.assertTrue(condition)  # True\nself.assertFalse(condition)  # False\n```\n\n**Проверка исключений:**\n```python\nself.assertRaises(ValueError, function, args)\nwith self.assertRaises(ValueError):\n    function(args)\n```\n\n**Проверка вхождения:**\n```python\nself.assertIn(item, container)  # item in container\nself.assertNotIn(item, container)  # item not in container\n```\n\n**Проверка типов:**\n```python\nself.assertIsInstance(obj, int)  # isinstance(obj, int)\nself.assertNotIsInstance(obj, str)  # not isinstance(obj, str)\n```\n\n## Практические примеры\n\n**Тестирование функций:**\n```python\nimport unittest\nfrom math import sqrt\n\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Деление на ноль\")\n    return a / b\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nclass TestMathFunctions(unittest.TestCase):\n    def test_divide_normal(self):\n        result = divide(10, 2)\n        self.assertEqual(result, 5)\n    \n    def test_divide_by_zero(self):\n        with self.assertRaises(ValueError):\n            divide(10, 0)\n    \n    def test_is_prime_true(self):\n        self.assertTrue(is_prime(7))\n        self.assertTrue(is_prime(13))\n    \n    def test_is_prime_false(self):\n        self.assertFalse(is_prime(4))\n        self.assertFalse(is_prime(1))\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n**Тестирование классов:**\n```python\nclass BankAccount:\n    def __init__(self, initial_balance=0):\n        self.balance = initial_balance\n    \n    def deposit(self, amount):\n        if amount < 0:\n            raise ValueError(\"Сумма не может быть отрицательной\")\n        self.balance += amount\n    \n    def withdraw(self, amount):\n        if amount < 0:\n            raise ValueError(\"Сумма не может быть отрицательной\")\n        if amount > self.balance:\n            raise ValueError(\"Недостаточно средств\")\n        self.balance -= amount\n\nclass TestBankAccount(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Выполняется перед каждым тестом\"\"\"\n        self.account = BankAccount(100)\n    \n    def test_initial_balance(self):\n        self.assertEqual(self.account.balance, 100)\n    \n    def test_deposit(self):\n        self.account.deposit(50)\n        self.assertEqual(self.account.balance, 150)\n    \n    def test_withdraw_success(self):\n        self.account.withdraw(30)\n        self.assertEqual(self.account.balance, 70)\n    \n    def test_withdraw_insufficient_funds(self):\n        with self.assertRaises(ValueError):\n            self.account.withdraw(200)\n    \n    def test_deposit_negative_amount(self):\n        with self.assertRaises(ValueError):\n            self.account.deposit(-50)\n```\n\n## Настройка и очистка\n\n**setUp и tearDown:**\n```python\nclass TestDatabase(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Подготовка перед каждым тестом\"\"\"\n        self.db = create_test_database()\n        self.user = create_test_user()\n    \n    def tearDown(self):\n        \"\"\"Очистка после каждого теста\"\"\"\n        self.db.close()\n        delete_test_user(self.user.id)\n    \n    def test_user_creation(self):\n        # Тест использует подготовленные данные\n        self.assertIsNotNone(self.user.id)\n```\n\n## Запуск тестов\n\n**Различные способы запуска:**\n```bash\n# Запуск всех тестов в файле\npython test_math.py\n\n# Запуск конкретного теста\npython -m unittest test_math.TestMathFunctions.test_addition\n\n# Запуск с подробным выводом\npython -m unittest -v test_math.py\n\n# Запуск всех тестов в модуле\npython -m unittest discover\n\n# Запуск с покрытием кода\npip install coverage\ncoverage run -m unittest test_math.py\ncoverage report\n```\n\n## Альтернативные фреймворки\n\n**pytest** — более современный и гибкий:\n```python\n# Установка\npip install pytest\n\n# Простой тест\ndef test_addition():\n    assert 2 + 2 == 4\n\ndef test_divide_by_zero():\n    with pytest.raises(ValueError):\n        divide(10, 0)\n\n# Запуск\npytest test_file.py\n```\n\n## Лучшие практики\n\n**Принципы хороших тестов:**\n- **AAA** — Arrange, Act, Assert\n- Один тест — одна проверка\n- Понятные имена тестов\n- Независимость тестов\n- Быстрое выполнение\n- Детерминированность\n\n**Структура тестов:**\n```python\nclass TestFeature(unittest.TestCase):\n    def test_should_return_correct_value_when_valid_input(self):\n        # Arrange (подготовка)\n        input_value = \"valid_input\"\n        expected = \"expected_output\"\n        \n        # Act (действие)\n        result = function_under_test(input_value)\n        \n        # Assert (проверка)\n        self.assertEqual(result, expected)\n```\n\n**Покрытие кода:**\n```bash\n# Установка инструмента покрытия\npip install coverage\n\n# Запуск с измерением покрытия\ncoverage run -m unittest discover\n\n# Отчет о покрытии\ncoverage report\ncoverage html  # HTML отчет\n```\n\n**Рекомендации:**\n- Стремитесь к 80%+ покрытию кода\n- Тестируйте граничные случаи\n- Используйте моки для внешних зависимостей\n- Автоматизируйте запуск тестов\n- Интегрируйте тесты в CI/CD",
    "tasks": [
        {
            "id": "m9t9",
            "question": "Какой модуль используется для тестирования в Python?",
            "answer": "unittest",
            "hint": "unittest — стандартный модуль для тестов."
        },
        {
            "id": "m9t10",
            "question": "От какого класса наследуется тестовый класс?",
            "answer": "TestCase",
            "hint": "unittest.TestCase"
        },
        {
            "id": "m9t11",
            "question": "Как проверить равенство в тесте?",
            "answer": "assertEqual()",
            "hint": "self.assertEqual(ожидаемое, фактическое)"
        },
        {
            "id": "m9t12",
            "question": "Как запустить все тесты?",
            "answer": "unittest.main()",
            "hint": "unittest.main() запускает все тесты."
        }
    ]
}
